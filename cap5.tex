\chapter{Implementación}

A continuación se mencionarán los pasos seguidos en la implementación. Estos serán explicados de forma concisa sin entrar en detalles de programación para un entendimiento más bien superficial de lo técnico, manteniendo una mirada global del cumplimiento del diseño y el modelo. De todas formas, en el primer apéndice se deja a disposición parte del código implementado para evidenciar detalles de la puesta en funcionamiento.

Para la implementación se utilizó como base lo hecho en las versiones pasadas del recuento de unidades docentes. En éstas el recuento se dividía en cuatro funciones importantes destacando dos de ellas: la inicial y la recursiva. La función inicial realiza la petición de los ramos y planes a partir del rut y carrera de un alumno, limpia estos datos, realiza asociaciones como las relaciones entre ramos de distintas versiones, llama a la función recursiva y, finalmente, retorna los resultados. Por otra parte, la recursiva realiza todo el procesamiento de la heurística anteriormente descrita llamándose a sí misma por cada asignación de ramo. Además, debe convocar a las otras dos funciones donde se propaga la elección de un ramo en un plan sobre todos los demás planes y el método en donde se evalúa si la solución actual es mejor que la guardada. Esta última también posee el contador de tiempo, donde si se exceden los quince segundos retorna la solución guardada por el momento y hace retornar los resultados desde la recursiva hacia la función inicial, para que esta los devuelva al controlador web que los solicitó.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.7]{imagenes/15}
	\caption{Funciones de la implementación anterior y sus comportamientos.}
	\label{impl_old}
\end{figure}

En este caso, se utilizó la misma forma de programación procurando que todas las funciones tuvieran una firma similar entre ellas, respetando que siempre reciban la lista de ramos y planes, y retornen la mejor solución si corresponde. Además, como no estaba dentro del alcance, se reutilizó la implementación hecha en la funcion inicial de la implementación anterior. Por lo tanto, se poseen seis funciones, donde tres de ellas se corresponden con las explicadas en el párrafo anterior exceptuando la recursiva, debido a que se cambió el comportamiento del algoritmo.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.2]{imagenes/16}
	\caption{Funciones de la nueva implementación y sus comportamientos.}
	\label{impl_new}
\end{figure}

Una de las funciones es el cálculo de las componentes conexas, donde a partir de los ramos se dividen en distintos arreglos debido a los planes que comparten. A esta función siempre se le entrega la lista de todos los ramos y planes, pero puede adicionarse una tercera variable opcional que dice que subconjunto de esas listas deben ser considerados para el cálculo y cuáles elementos deben quedan fuera.

Otra función es el cálculo de la mejor solución a partir de un arreglo de soluciones. En ella se recibe un arreglo y en una variable auxiliar se va guardando la mejor mientras se recorre el arreglo. Al término retorna aquella variable.

La función recursiva de la implementación antigua se cambió por dos funciones nuevas. La primera es el paso intermedio donde se calculan las componentes conexas y por cada una de ellas se inicia el cómputo de las distintas opciones de un ramo. La segunda es la que realiza este cálculo, elige un ramo y evalúa todas sus opciones (llamando a la primera función) generando un arreglo de posibles soluciones el que es pasado al método explicado en el párrafo anterior donde se calcula cuál es mejor.

En la primera función descrita en el párrafo anterior es donde debe ir ubicada la implementación del caché. Alli, se debe encontrar una firma (hash) que diferencie los elementos a guardar en memoria de manera tal de discriminar cuál componente conexa generada está repitiendo su cálculo para ser extraida desde la memoria y no necesitar el llamado a la segunda función.

Finalmente, se posee la función que realiza un recorrido con orden posterior (post order traversal) del árbol de planes para propagar las elecciones hechas en cada paso del segundo método explicado en el párrafo anterior.
